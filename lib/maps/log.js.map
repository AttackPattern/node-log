{"version":3,"sources":["log.js"],"names":["appStart","Date","Log","bus","Bus","note","subject","LogActivity","_this","enter","section","extension","this","with","subscription","subscribe","publisher","_classCallCheck3","default","extensions","entries","active","entry","publishEntry","copy","push","publish","error","start","LogEntry","method","startTime","time","exiting","stopTime","caller","Error","_extends3","entering","exit","undefined","e","addNote","addArguments","_this3","arguments","args","Array","prototype","slice","call","_stringify2","stack","clone","appElapsed","elapsed","Math","max","subscriptions","when","callback","condition","_this2","message","payload","sub","unsubscribe","filter","next","forEach"],"mappings":"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","file":"../log.js","sourcesContent":["const appStart = new Date();\n\nexport default class Log {\n  bus = new Bus();\n\n  with(extension) {\n    return new LogActivity(this.bus).with(extension);\n  }\n  note = subject => {\n    return new LogActivity(this.bus).note(subject); // TODO (brett) - get these arguments: , Log.note.caller);\n  }\n  enter = section => {\n    return new LogActivity(this.bus).enter(section); // TODO (brett) - get these arguments: , Log.enter.caller);\n  }\n  subscribe(subscription) {\n    return this.bus.subscribe(subscription);\n  }\n}\n\nclass LogActivity {\n  extensions = {}\n  entries = []\n  active = true\n\n  constructor(publisher) {\n    this.publisher = publisher;\n  }\n\n  publish(entry) {\n    var publishEntry = {\n      ...entry.copy(),\n      ...this.extensions\n    };\n    this.entries.push(publishEntry);\n    this.publisher.publish(publishEntry);\n    return entry;\n  }\n\n  exit(error) {\n    this.active = false;\n    const start = this.entries[0];\n    const entry = new LogEntry(error || 'exiting activity', start.method);\n    entry.entries = this.entries;\n    entry.startTime = start.time;\n    entry.exiting = true;\n    entry.stopTime = new Date();\n\n    this.publish(entry);\n  }\n\n  note(subject, caller) {\n    if (!this.active) {\n      throw new Error('Note called on a completed activity');\n    }\n    const note = new LogEntry(subject, caller); // TODO (brett) - get these arguments: || this.note.caller);\n    return this.publish({\n      ...note,\n      ...this.extensions\n    });\n  }\n\n  with(extension) {\n    if (extension) {\n      this.extensions = {\n        ...this.extensions,\n        ...extension\n      };\n    }\n    return this;\n  }\n\n  enter(section, caller) {\n    var entry = new LogEntry('entering activity', caller || this.enter.caller);\n    entry.entering = true;\n    this.publish(entry);\n\n    this.exit = exit;\n\n    if (!section) {\n      this.enter = undefined;\n      return this;\n    }\n\n    try {\n      section(this);\n      this.exit();\n    } catch (e) {\n      this.exit(e);\n      throw e;\n    }\n    return null;\n  }\n}\n\n\nclass LogEntry {\n  constructor(subject, caller) {\n    // TODO (brett) - get caller name: \n    // this.method = caller.name || 'anonymous';\n    this.time = new Date();\n\n    this.addNote(subject);\n    this.addArguments(caller);\n  }\n\n  addNote = note => {\n    if (!note) {\n      return;\n    }\n    if (typeof note === 'string') {\n      this.message = note;\n    }\n    else if (note instanceof Error) {\n      this.error = note;\n    }\n    else {\n      this.subject = note;\n    }\n  }\n\n  addArguments = caller => {\n    try {\n      if (caller.arguments) {\n        // TODO (brett) - Why all the ceremony?\n        const args = Array.prototype.slice.call(caller.arguments);\n        JSON.stringify(args); // assure arguments are not cyclic\n        this.arguments = args;\n      }\n    }\n    catch (e) {\n      this.arguments = 'Cyclic arguments';\n    }\n  }\n\n  stack = () => {\n    return stack({ e: this.error });\n  }\n\n  copy = () => ({\n    ...new LogEntry(null, this.method),\n    ...this,\n    clone: true\n  })\n  appStart = () => appStart\n  appElapsed = () => this.time - appStart\n  elapsed = () => Math.max(0, this.time - this.startTime)\n}\n\nclass Bus {\n  subscriptions = []\n  subscribe(callback) {\n    return this.when().subscribe(callback);\n  }\n  when(condition) {\n    return {\n      subscribe: callback => {\n        function sub(payload) {\n          if (!condition || condition(payload)) {\n            callback(payload);\n          }\n        };\n        this.subscriptions.push(sub);\n\n        return {\n          unsubscribe: () => {\n            this.subscriptions = this.subscriptions.filter(next => next !== sub);\n          }\n        };\n      }\n    };\n  }\n  publish(subject) {\n    this.subscriptions.forEach(sub => {\n      try {\n        sub(subject);\n      }\n      catch (e) {\n        // Honey badger\n      }\n    });\n  }\n}\n"]}